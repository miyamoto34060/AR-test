<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <title>WebAR 静的配置＋センサー融合＋リロード</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <!-- A-Frame, AR.js, Axios -->
  <script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js/aframe/build/aframe-ar.min.js"></script>
  <script src="https://unpkg.com/axios/dist/axios.min.js"></script>
  <style>
    html, body { margin: 0; overflow: hidden; }
    a-scene { height: 100vh; width: 100vw; }
    /* 再読み込みボタン */
    #reloadBtn {
      position: fixed;
      top: 10px;
      right: 10px;
      z-index: 10000;
      padding: 8px 12px;
      background: rgba(0,0,0,0.6);
      color: #fff;
      border: none;
      border-radius: 4px;
      font-size: 14px;
    }
  </style>

  <!-- ▼ センサー融合（移動平均＋EMA＋IMU）による GPS 補正 -->
  <script>
  (function(){
    // 元の watchPosition を保存
    const origWatch = navigator.geolocation.watchPosition.bind(navigator.geolocation);

    // １）平滑化パラメータ
    const windowSize = 5, alpha = 0.2;
    let latBuf = [], lonBuf = [], emaLat, emaLon;

    // ２）IMU（加速度）統合用
    let velX = 0, velY = 0, lastMotionTime = null;
    window.addEventListener('devicemotion', e => {
      const t = e.timeStamp;
      if (lastMotionTime !== null) {
        const dt = (t - lastMotionTime) / 1000;
        const ax = e.acceleration.x || 0;
        const ay = e.acceleration.y || 0;
        velX += ax * dt;
        velY += ay * dt;
      }
      lastMotionTime = t;
    });

    // オーバーライドして補正付きの watchPosition を提供
    navigator.geolocation.watchPosition = function(success, error, options) {
      return origWatch(function(pos) {
        // ──────────
        // A. GPS 平滑化（移動平均 → EMA）
        // ──────────
        const rawLat = pos.coords.latitude;
        const rawLon = pos.coords.longitude;
        latBuf.push(rawLat); if (latBuf.length > windowSize) latBuf.shift();
        lonBuf.push(rawLon); if (lonBuf.length > windowSize) lonBuf.shift();
        const avgLat = latBuf.reduce((a,b)=>a+b,0) / latBuf.length;
        const avgLon = lonBuf.reduce((a,b)=>a+b,0) / lonBuf.length;
        if (emaLat === undefined) {
          emaLat = avgLat; emaLon = avgLon;
        } else {
          emaLat = alpha * avgLat + (1 - alpha) * emaLat;
          emaLon = alpha * avgLon + (1 - alpha) * emaLon;
        }

        // ──────────
        // B. IMU 補正（速度→緯度経度オフセット）
        // ──────────
        const mPerDeg = 111000; // 1度あたり約111km
        const dt = lastMotionTime ? (Date.now() - lastMotionTime) / 1000 : 0;
        const dLat = (velY * dt) / mPerDeg;
        const dLon = (velX * dt) / (mPerDeg * Math.cos(emaLat * Math.PI/180));

        // 最終的に補正済みの座標を上書き
        pos.coords.latitude  = emaLat + dLat;
        pos.coords.longitude = emaLon + dLon;

        // 元のコールバックに渡す
        success(pos);
      }, error, options);
    };
  })();
  </script>
  <!-- ▲ ここまでセンサー融合 -->
</head>

<body>
  <!-- 手動リロードボタン -->
  <button id="reloadBtn">再読み込み</button>

  <!-- WebAR シーン -->
  <a-scene embedded arjs="sourceType: webcam; debugUIEnabled: true;">
    <a-camera gps-camera rotation-reader></a-camera>
  </a-scene>

  <script>
    // ──────────
    // 1. 静的マーカー配置
    // ──────────
    window.addEventListener('load', () => {
      axios.get('line_to_points.geojson')
        .then(res => {
          res.data.features.forEach(feature => {
            if (feature.geometry.type === "Point") {
              const [lon, lat] = feature.geometry.coordinates.map(parseFloat);
              const marker = document.createElement('a-sphere');
              // 一度だけ緯度経度→ワールド座標に変換して固定
              marker.setAttribute('gps-projected-entity-place', `latitude: ${lat}; longitude: ${lon}`);
              marker.setAttribute('radius', '0.5');
              marker.setAttribute('color', 'blue');
              document.querySelector('a-scene').appendChild(marker);
            }
          });
        })
        .catch(err => console.error('GeoJSON読み込み失敗:', err));
    });

    // ──────────
    // 2. 手動リロード
    // ──────────
    document.getElementById('reloadBtn').addEventListener('click', () => {
      location.reload();
    });

    // ──────────
    // 3. 自動リロード（100m 移動でページ再読み込み）
    // ──────────
    let initialLat = null, initialLon = null;
    const THRESHOLD = 100; // メートル

    function haversine(lat1, lon1, lat2, lon2) {
      const R = 6371000, toRad = Math.PI/180;
      const dLat = (lat2 - lat1) * toRad;
      const dLon = (lon2 - lon1) * toRad;
      const a = Math.sin(dLat/2)**2 +
                Math.cos(lat1*toRad) * Math.cos(lat2*toRad) * Math.sin(dLon/2)**2;
      return 2 * R * Math.asin(Math.sqrt(a));
    }

    navigator.geolocation.watchPosition(pos => {
      const lat = pos.coords.latitude;
      const lon = pos.coords.longitude;
      if (initialLat === null) {
        initialLat = lat;
        initialLon = lon;
      } else {
        const dist = haversine(initialLat, initialLon, lat, lon);
        if (dist > THRESHOLD) {
          console.log(`移動距離 ${Math.round(dist)}m を検出。ページを再読み込みします。`);
          location.reload();
        }
      }
    }, err => {
      console.error('自動リロード用GPS取得エラー:', err);
    }, {
      enableHighAccuracy: true,
      maximumAge: 1000,
      timeout: 5000
    });
  </script>
</body>
</html>
