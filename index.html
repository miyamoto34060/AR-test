<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <title>WebAR キャリブレーション＋静的配置＋センサー融合＋リロード</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <!-- A-Frame, AR.js, Axios -->
  <script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js/aframe/build/aframe-ar.min.js"></script>
  <script src="https://unpkg.com/axios/dist/axios.min.js"></script>
  <style>
    html, body { margin: 0; overflow: hidden; }
    a-scene { height: 100vh; width: 100vw; }

    /* 再読み込みボタン */
    #reloadBtn {
      position: fixed;
      top: 10px;
      right: 10px;
      z-index: 10000;
      padding: 8px 12px;
      background: rgba(0,0,0,0.6);
      color: #fff;
      border: none;
      border-radius: 4px;
      font-size: 14px;
    }

    /* トースト表示用メッセージ */
    #toast {
      position: fixed;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.7);
      color: #fff;
      padding: 6px 12px;
      border-radius: 4px;
      display: none;
      z-index: 10001;
      font-size: 14px;
    }
  </style>

  <!-- ▼ センサー融合（移動平均＋EMA＋IMU）＋キャリブレーションオフセット -->
  <script>
    (function(){
      const origWatch = navigator.geolocation.watchPosition.bind(navigator.geolocation);

      // 平滑化パラメータ
      const windowSize = 5, alpha = 0.2;
      let latBuf = [], lonBuf = [], emaLat, emaLon;

      // IMU 用
      let velX = 0, velY = 0, lastMotionTime = null;
      window.addEventListener('devicemotion', e => {
        const t = e.timeStamp;
        if (lastMotionTime !== null) {
          const dt = (t - lastMotionTime) / 1000;
          velX += (e.acceleration.x || 0) * dt;
          velY += (e.acceleration.y || 0) * dt;
        }
        lastMotionTime = t;
      });

      // キャリブレーションオフセット
      window.calibOffLat = 0;
      window.calibOffLon = 0;
      // 最終GPS位置
      window.lastGpsLat = null;
      window.lastGpsLon = null;

      navigator.geolocation.watchPosition = function(success, error, options) {
        return origWatch(function(pos) {
          // A. 移動平均→EMA
          const rawLat = pos.coords.latitude;
          const rawLon = pos.coords.longitude;
          latBuf.push(rawLat); if (latBuf.length > windowSize) latBuf.shift();
          lonBuf.push(rawLon); if (lonBuf.length > windowSize) lonBuf.shift();
          const avgLat = latBuf.reduce((a,b)=>a+b, 0) / latBuf.length;
          const avgLon = lonBuf.reduce((a,b)=>a+b, 0) / lonBuf.length;
          if (emaLat === undefined) {
            emaLat = avgLat; emaLon = avgLon;
          } else {
            emaLat = alpha * avgLat + (1 - alpha) * emaLat;
            emaLon = alpha * avgLon + (1 - alpha) * emaLon;
          }

          // B. IMU 補正
          const mPerDeg = 111000;
          const dt = lastMotionTime ? (Date.now() - lastMotionTime) / 1000 : 0;
          const dLat = (velY * dt) / mPerDeg;
          const dLon = (velX * dt) / (mPerDeg * Math.cos(emaLat * Math.PI/180));

          // C. キャリブレーションオフセット
          let correctedLat = emaLat + dLat + window.calibOffLat;
          let correctedLon = emaLon + dLon + window.calibOffLon;

          // 最終GPSを書き戻し
          pos.coords.latitude  = correctedLat;
          pos.coords.longitude = correctedLon;
          window.lastGpsLat = correctedLat;
          window.lastGpsLon = correctedLon;

          success(pos);
        }, error, options);
      };
    })();
  </script>
</head>

<body>
  <!-- トースト表示 -->
  <div id="toast"></div>

  <!-- 再読み込みボタン -->
  <button id="reloadBtn">再読み込み</button>

  <!-- WebAR シーン -->
  <a-scene embedded arjs="sourceType: webcam; debugUIEnabled: true;">
    <a-camera gps-camera rotation-reader></a-camera>
  </a-scene>

  <script>
    // ──────────
    // ヘルパー：トースト表示（非ブロッキング）
    // ──────────
    function showToast(msg, duration = 2000) {
      const t = document.getElementById('toast');
      t.innerText = msg;
      t.style.display = 'block';
      clearTimeout(t._hideTimeout);
      t._hideTimeout = setTimeout(() => t.style.display = 'none', duration);
    }

    // ──────────
    // 1. 静的マーカー配置
    // ──────────
    async function placeMarkers() {
      const scene = document.querySelector('a-scene');
      document.querySelectorAll('.calib').forEach(el => el.remove());
      try {
        const res = await axios.get('line_to_points.geojson');
        res.data.features.forEach(f => {
          if (f.geometry.type === 'Point') {
            const [lon, lat] = f.geometry.coordinates.map(parseFloat);
            const marker = document.createElement('a-sphere');
            marker.classList.add('calib');
            marker.setAttribute('data-lat', lat);
            marker.setAttribute('data-lon', lon);
            marker.setAttribute(
              'gps-projected-entity-place',
              `latitude:${lat};longitude:${lon}`
            );
            marker.setAttribute('radius', '0.5');
            marker.setAttribute('color', 'blue');
            scene.appendChild(marker);
          }
        });
      } catch (err) {
        console.error('GeoJSON読み込み失敗:', err);
      }
    }
    window.addEventListener('load', placeMarkers);

    // ──────────
    // 2. マーカー再配置ヘルパー
    // ──────────
    function updateMarkers() {
      document.querySelectorAll('.calib').forEach(el => {
        const baseLat = parseFloat(el.getAttribute('data-lat'));
        const baseLon = parseFloat(el.getAttribute('data-lon'));
        const adjLat  = baseLat + window.calibOffLat;
        const adjLon  = baseLon + window.calibOffLon;
        el.setAttribute(
          'gps-projected-entity-place',
          `latitude:${adjLat};longitude:${adjLon}`
        );
      });
    }

    // ──────────
    // 3. タップ補正
    // ──────────
    (function(){
      const sceneEl  = document.querySelector('a-scene');
      const cameraEl = document.querySelector('a-camera');
      const raycaster = new THREE.Raycaster();
      const mouse     = new THREE.Vector2();

      sceneEl.addEventListener('click', evt => {
        mouse.x = (evt.clientX / window.innerWidth) * 2 - 1;
        mouse.y = - (evt.clientY / window.innerHeight) * 2 + 1;
        const cam3D = cameraEl.getObject3D('camera');
        raycaster.setFromCamera(mouse, cam3D);

        // メッシュ部分だけ取得
        const meshes = Array.from(document.querySelectorAll('.calib'))
          .map(el => el.getObject3D('mesh'))
          .filter(mesh => mesh);
        const hits = raycaster.intersectObjects(meshes, true);
        if (!hits.length) {
          showToast('マーカーをタップしてください');
          return;
        }

        // ヒットした Mesh からエンティティを取得
        const mesh = hits[0].object;
        const el   = mesh.el;
        const trueLat = parseFloat(el.getAttribute('data-lat'));
        const trueLon = parseFloat(el.getAttribute('data-lon'));
        const curLat  = window.lastGpsLat;
        const curLon  = window.lastGpsLon;
        if (curLat == null) {
          showToast('GPS取得待ち…');
          return;
        }

        // 誤差オフセットを計算
        window.calibOffLat = trueLat - curLat;
        window.calibOffLon = trueLon - curLon;

        // マーカーを再配置
        updateMarkers();
        showToast('キャリブレーション完了');
      });
    })();

    // ──────────
    // 4. 手動リロード
    // ──────────
    document.getElementById('reloadBtn').addEventListener('click', () => {
      showToast('ページを再読み込み中…');
      location.reload();
    });

    // ──────────
    // 5. 自動リロード（100m移動）
    // ──────────
    let initialLat = null, initialLon = null;
    const THRESHOLD = 100;
    function haversine(lat1, lon1, lat2, lon2) {
      const R = 6371000, r = Math.PI/180;
      const dLat = (lat2 - lat1) * r;
      const dLon = (lon2 - lon1) * r;
      const a = Math.sin(dLat/2)**2 +
                Math.cos(lat1*r) * Math.cos(lat2*r) * Math.sin(dLon/2)**2;
      return 2 * R * Math.asin(Math.sqrt(a));
    }
    navigator.geolocation.watchPosition(pos => {
      const { latitude: lat, longitude: lon } = pos.coords;
      if (initialLat === null) {
        initialLat = lat; initialLon = lon;
      } else if (haversine(initialLat, initialLon, lat, lon) > THRESHOLD) {
        showToast('大幅移動を検出。再読み込みします。');
        location.reload();
      }
    }, console.error, {
      enableHighAccuracy: true,
      maximumAge: 1000,
      timeout: 5000
    });
  </script>
</body>
</html>
